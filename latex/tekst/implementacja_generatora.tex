\chapter{Implementacja generatora na platformie FPGA}

W niniejszym rozdziale przedstawiono praktyczną implementację cyfrowego
generatora liczb losowych wykorzystującego oscylator pierścieniowy jako
źródło entropii. Opis obejmuje wybór środowiska projektowego oraz
platformy sprzętowej, a następnie proces syntezy, implementacji i
uruchomienia układu na fizycznej płytce FPGA. Celem rozdziału jest
przedstawienie pełnego przepływu projektowego, od opisu sprzętowego do
działającej realizacji.

\section{Środowisko projektowe Vivado i wybór platformy sprzętowej}

Do realizacji projektu wybrano środowisko Xilinx Vivado Design Suite,
które stanowi podstawowe narzędzie do projektowania, syntezy oraz
implementacji układów FPGA firmy Xilinx. Vivado umożliwia opis logiki
sprzętowej w językach HDL, przeprowadzenie syntezy logicznej,
rozmieszczenia i trasowania zasobów, a także generację pliku konfiguracyjnego
(bitstream) i programowanie układu docelowego.

Istotną zaletą środowiska Vivado jest pełna kontrola nad strukturą
projektowanego układu oraz dostęp do raportów czasowych i zasobowych,
co ma kluczowe znaczenie w przypadku oscylatorów pierścieniowych.
Niewielkie różnice w opóźnieniach propagacji bramek oraz sposób
rozmieszczenia logiki w strukturze FPGA mają bezpośredni wpływ na
właściwości generowanego sygnału i poziom entropii.

Jako platformę sprzętową wybrano płytkę rozwojową Arty S7--25 z układem
Xilinx Spartan-7. Jest to nowoczesny układ FPGA przeznaczony do aplikacji
o umiarkowanej złożoności, oferujący dobrą relację dostępnych zasobów
logicznych do poboru mocy i kosztu. Rodzina Spartan-7 zapewnia stabilne
parametry czasowe oraz powtarzalne zachowanie struktur logicznych, co
jest istotne w kontekście implementacji generatorów liczb losowych.

Dodatkowym argumentem przemawiającym za wyborem płytki Arty S7--25 jest jej
szerokie wsparcie narzędziowe oraz dostępność dokumentacji i przykładów
projektowych. Płytka posiada standardowy interfejs JTAG do programowania
i debugowania, co umożliwia wygodne testowanie implementacji oraz
obserwację zachowania układu w warunkach rzeczywistych.

\section{Implementacja oscylatora pierścieniowego w języku VHDL}

W niniejszym podrozdziale przedstawiono implementację testową oscylatora 
pierścieniowego oraz nadrzędnego modułu generatora liczb losowych,
opracowaną w języku VHDL i przeznaczoną do syntezy w strukturze FPGA.

\begin{lstlisting}[language=VHDL,
caption={Moduł oscylatora pierścieniowego (ring\_oscillator.vhdl)},
label={lst:ring_oscillator}]
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ring_oscillator is
    generic ( INVERTERS_NUM : integer := 5 );                        
    port    ( ro_out : out std_logic       );                              
end ring_oscillator;

\end{lstlisting}

Listing~\ref{lst:ring_oscillator} przedstawia prostą, parametryzowaną implementację
oscylatora pierścieniowego w języku VHDL. Zastosowane rozwiązanie odwzorowuje klasyczną 
ideę oscylatora pierścieniowego znaną z elektroniki cyfrowej: nieparzystą liczbę inwerterów
połączonych szeregowo w pętlę zwrotną, w której brak stabilnego stanu logicznego wymusza ciągłe przełączanie.
Rdzeniem projektu jest wektor sygnałów \texttt{chain} którego długość jest określona parametrem
generycznym \texttt{INVERTERS\_NUM}. Każdy element tego wektora odpowiada jednemu stopniowi inwersji.
Pierwszy stopień otrzymuje na wejście zanegowany sygnał z ostatniego elementu łańcucha,
co zamyka pętlę sprzężenia zwrotnego. Kolejne stopnie realizują prostą inwersję sygnału
z poprzedniego etapu.
Kluczowym elementem implementacyjnym jest użycie atrybutu \texttt{dont\_touch}, przypisanego do 
sygnału \texttt{chain}. Atrybut ten informuje narzędzia syntezy\cite{amd_vivado_donttouch}, 
że pętla kombinacyjna nie jest błędem projektowym, lecz zamierzoną strukturą funkcjonalną. 
Bez tej deklaracji optymalizator mógłby usunąć lub uprościć logikę, traktując ją jako zbędną 
lub niepoprawną. W praktyce atrybut zwiększa szansę zachowania fizycznej struktury pierścienia 
w docelowym układzie FPGA, co jest warunkiem powstania oscylacji.
Sygnał wyjściowy \texttt{ro\_out} jest bezpośrednio pobierany z ostatniego stopnia łańcucha inwerterów.
Jego częstotliwość zależy od liczby stopni inwersji oraz opóźnień propagacji w danej technologii 
sprzętowej. Dzięki użyciu parametru generycznego możliwa jest łatwa modyfikacja liczby inwerterów,
a tym samym regulacja częstotliwości oscylatora bez ingerencji w strukturę kodu.
Całość architektury ma charakter czysto kombinacyjny i świadomie narusza klasyczne zasady
projektowania synchronicznego, co czyni ją przykładem konstrukcji niskopoziomowej,
silnie zależnej od właściwości fizycznych układu docelowego, a nie tylko od opisu logicznego.

\begin{lstlisting}[language=VHDL,
caption={Moduł generatora liczb losowych oparty na oscylatorach pierścieniowych (\texttt{trng\_ro.vhdl})},
label={lst:trng_ro}]
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity trng_ro is
    generic (
        NUM_RO    : integer := 8;
        RO_STAGES : integer := 5
    );
    port (
        clk        : in  std_logic;
        rst_n      : in  std_logic;
        random_bit : out std_logic
    );
end trng_ro;

\end{lstlisting}

Listing~\ref{lst:trng_ro} przedstawia nadrzędny moduł generatora liczb losowych opartego na zespole
oscylatorów pierścieniowych. Moduł realizuje architekturę TRNG, w której źródłem entropii są 
fluktuacje czasowe i jitter wielu niezależnych oscylatorów, a ich próbki są synchronizowane 
zegarem systemowym.

Parametry generyczne \texttt{NUM\_RO} oraz \texttt{RO\_STAGES} umożliwiają odpowiednio konfigurację 
liczby instancji oscylatorów pierścieniowych oraz liczby stopni inwersji w każdym z nich. Pozwala 
to na łatwe dostosowanie charakterystyk generatora, takich jak poziom entropii czy pobór zasobów 
logicznych, do wymagań aplikacji oraz technologii docelowej.

Wyjścia wszystkich oscylatorów są gromadzone w wektorze \texttt{ro\_vector}, który został oznaczony 
atrybutem \texttt{dont\_touch}. Zapobiega to ingerencji narzędzi syntezy w strukturę fizyczną 
zespołu oscylatorów, co ma kluczowe znaczenie dla zachowania ich niezależności czasowej oraz 
właściwości losowych.

W celu wstępnego „wybielenia” sygnału losowego zastosowano funkcję redukującą XOR, która łączy 
stany logiczne wszystkich oscylatorów w pojedynczy sygnał \texttt{xor\_raw}. Takie podejście 
zmniejsza wpływ ewentualnych korelacji pomiędzy pojedynczymi oscylatorami i poprawia statystyczne 
właściwości wyjścia.

Próbowanie sygnału losowego odbywa się w procesie synchronicznym względem zegara \texttt{clk}. 
Dwustopniowy rejestr synchronizujący pełni podwójną rolę: pierwszy przerzutnik próbuje 
asynchroniczny sygnał pochodzący z oscylatorów, natomiast drugi stabilizuje jego wartość, 
ograniczając propagację metastabilności do dalszej logiki. Wyjście generatora \texttt{random\_bit} 
jest pobierane z drugiego stopnia synchronizacji.

Przedstawiona architektura stanowi typowy przykład konstrukcji TRNG silnie zależnej od właściwości 
fizycznych układu FPGA, w której losowość nie wynika z algorytmu, lecz z niedeterministycznych 
zjawisk czasowych zachodzących w strukturze sprzętowej.

\section{Implementacja protokołu UART do transmisji ciągu losowych bitow}

W niniejszym podrozdziale przedstawiono implementację protokołu UART, przeznaczoną do 
transmisji ciągu losowych bitów generowanych przez moduł \texttt{trng\_ro}. Celem tego etapu 
projektu jest umożliwienie niezależnej, asynchronicznej komunikacji pomiędzy układem FPGA a 
systemem zewnętrznym, w którym dane losowe mogą być dalej przetwarzane lub analizowane.

\begin{lstlisting}[language=VHDL,
caption={Moduł bufora UART (uart\_buff.vhdl)},
label={lst:uart_buff}]
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity uart_buff is
    generic (
        
    );
    port (
        
    );
end uart_buff;
\end{lstlisting}

Listing~\ref{lst:uart_buff} przedstawia architekturę pośrednią. Z uwagi na bitowy charakter 
wyjścia generatora \texttt{trng\_ro} moduł \texttt{uart\_buff} stopniowo agreguje pojedyncze bity
do postaci bajtów, zgodnej z formatem transmisji UART. Rozwiązanie to oddziela 
warstwę generacji entropii od warstwy komunikacyjnej, upraszczając zarówno projekt, jak i 
późniejszą weryfikację poszczególnych bloków funkcjonalnych.
Implementacja została podzielona na dwa współpracujące moduły: bufor danych odpowiedzialny 
za gromadzenie bitów losowych oraz nadajnik UART realizujący właściwy proces transmisji 
szeregowej. Takie rozdzielenie funkcjonalności pozwala na zachowanie czytelnej struktury 
projektu oraz ułatwia ewentualną rozbudowę lub modyfikację parametrów transmisji w dalszych 
etapach pracy.
W kolejnych fragmentach podrozdziału zaprezentowano implementację poszczególnych modułów 
w języku VHDL, a następnie omówiono ich rolę w kontekście całego toru transmisji danych losowych.
